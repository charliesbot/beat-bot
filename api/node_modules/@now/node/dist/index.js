"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const ncc_watcher_1 = require("@zeit/ncc-watcher");
const build_utils_1 = require("@now/build-utils");
exports.shouldServe = build_utils_1.shouldServe;
const launcher_1 = require("./launcher");
const watchers = new Map();
function getWatcher(entrypoint, options) {
    let watcher = watchers.get(entrypoint);
    if (!watcher) {
        watcher = new ncc_watcher_1.NccWatcher(entrypoint, options);
        watchers.set(entrypoint, watcher);
    }
    return watcher;
}
function toBuffer(data) {
    if (typeof data === 'string') {
        return Buffer.from(data, 'utf8');
    }
    return data;
}
async function downloadInstallAndBundle({ files, entrypoint, workPath, meta, }) {
    console.log('downloading user files...');
    const downloadedFiles = await build_utils_1.download(files, workPath, meta);
    console.log("installing dependencies for user's code...");
    const entrypointFsDirname = path_1.join(workPath, path_1.dirname(entrypoint));
    const nodeVersion = await build_utils_1.getNodeVersion(entrypointFsDirname);
    const spawnOpts = build_utils_1.getSpawnOptions(meta, nodeVersion);
    await build_utils_1.runNpmInstall(entrypointFsDirname, ['--prefer-offline'], spawnOpts);
    const entrypointPath = downloadedFiles[entrypoint].fsPath;
    return { entrypointPath, entrypointFsDirname, nodeVersion, spawnOpts };
}
async function compile(workPath, entrypointPath, entrypoint, config, { isDev, filesChanged, filesRemoved }) {
    const input = entrypointPath;
    const inputDir = path_1.dirname(input);
    const rootIncludeFiles = inputDir.split(path_1.sep).pop() || '';
    const options = {
        sourceMap: true,
        sourceMapRegister: true,
    };
    let code;
    let map;
    let assets;
    let watch = [];
    if (isDev) {
        const watcher = getWatcher(entrypointPath, options);
        const result = await watcher.build(Array.isArray(filesChanged)
            ? filesChanged.map(f => path_1.join(workPath, f))
            : undefined, Array.isArray(filesRemoved)
            ? filesRemoved.map(f => path_1.join(workPath, f))
            : undefined);
        code = result.code;
        map = result.map;
        assets = result.assets;
        watch = [...result.files, ...result.dirs, ...result.missing]
            .filter(f => f.startsWith(workPath))
            .map(f => path_1.relative(workPath, f))
            .concat(Object.keys(assets || {}));
    }
    else {
        const ncc = require('@zeit/ncc');
        const result = await ncc(input, {
            sourceMap: true,
            sourceMapRegister: true,
        });
        code = result.code;
        map = result.map;
        assets = result.assets;
    }
    if (!assets)
        assets = {};
    if (config && config.includeFiles) {
        const includeFiles = typeof config.includeFiles === 'string'
            ? [config.includeFiles]
            : config.includeFiles;
        for (const pattern of includeFiles) {
            const files = await build_utils_1.glob(pattern, inputDir);
            for (const assetName of Object.keys(files)) {
                const stream = files[assetName].toStream();
                const { mode } = files[assetName];
                const { data } = await build_utils_1.FileBlob.fromStream({ stream });
                let fullPath = path_1.join(rootIncludeFiles, assetName);
                // if asset contain directory
                // no need to use `rootIncludeFiles`
                if (assetName.includes(path_1.sep)) {
                    fullPath = assetName;
                }
                assets[fullPath] = {
                    source: toBuffer(data),
                    permissions: mode,
                };
            }
        }
    }
    const preparedFiles = {};
    preparedFiles[entrypoint] = new build_utils_1.FileBlob({ data: code });
    if (map) {
        preparedFiles[`${entrypoint.replace('.ts', '.js')}.map`] = new build_utils_1.FileBlob({
            data: toBuffer(map),
        });
    }
    // move all user code to 'user' subdirectory
    // eslint-disable-next-line no-restricted-syntax
    for (const assetName of Object.keys(assets)) {
        const { source: data, permissions: mode } = assets[assetName];
        const blob2 = new build_utils_1.FileBlob({ data, mode });
        preparedFiles[path_1.join(path_1.dirname(entrypoint), assetName)] = blob2;
    }
    return { preparedFiles, watch };
}
exports.version = 2;
exports.config = {
    maxLambdaSize: '5mb',
};
async function build({ files, entrypoint, workPath, config, meta = {}, }) {
    const shouldAddHelpers = !(config && config.helpers === false);
    const { entrypointPath, entrypointFsDirname, nodeVersion, spawnOpts, } = await downloadInstallAndBundle({
        files,
        entrypoint,
        workPath,
        meta,
    });
    console.log('running user script...');
    await build_utils_1.runPackageJsonScript(entrypointFsDirname, 'now-build', spawnOpts);
    console.log('compiling entrypoint with ncc...');
    const { preparedFiles, watch } = await compile(workPath, entrypointPath, entrypoint, config, meta);
    const launcherFiles = {
        'launcher.js': new build_utils_1.FileBlob({
            data: launcher_1.makeLauncher(entrypoint, shouldAddHelpers),
        }),
        'bridge.js': new build_utils_1.FileFsRef({ fsPath: require('@now/node-bridge') }),
    };
    if (shouldAddHelpers) {
        launcherFiles['helpers.js'] = new build_utils_1.FileFsRef({
            fsPath: path_1.join(__dirname, 'helpers.js'),
        });
    }
    const lambda = await build_utils_1.createLambda({
        files: {
            ...preparedFiles,
            ...launcherFiles,
        },
        handler: 'launcher.launcher',
        runtime: nodeVersion.runtime,
    });
    const output = { [entrypoint]: lambda };
    const result = { output, watch };
    return result;
}
exports.build = build;
async function prepareCache({ workPath }) {
    return {
        ...(await build_utils_1.glob('node_modules/**', workPath)),
        ...(await build_utils_1.glob('package-lock.json', workPath)),
        ...(await build_utils_1.glob('yarn.lock', workPath)),
    };
}
exports.prepareCache = prepareCache;
