import ncc from '@zeit/ncc';
import { createDeferred, Deferred } from './deferred';

// Based on the NodeWatchFileSystem class at:
// - https://github.com/webpack/webpack/blob/master/lib/node/NodeWatchFileSystem.js
// which in turn exposes:
// - https://www.npmjs.com/package/watchpack
export interface FileMeta {
  safeTime?: number;
  accuracy?: number;
  timestamp?: number;
}
export interface InputFileSystem {
  purge: (file: string) => void
}
export type Timestamps = Map<string, FileMeta | null>;
export type ChangeCallback = (
  err: Error | null,
  timestamps1: Timestamps,
  timestamps2: Timestamps,
  removed: string[],
) => void;
export type WatchStart = (
  files: string[],
  dirs: string[],
  missing: string[]
) => void;
export type WatchEnd = () => void;

export class CustomWatchFileSystem {
  private closed: boolean;
  private paused: boolean;
  private files: Set<string> | undefined;
  private dirs: Set<string> | undefined;
  private missing: Set<string> | undefined;
  private timestamps: Timestamps;
  private inputFileSystem: InputFileSystem | undefined;
  private changeCallback: ChangeCallback | undefined;
  private watchStart: WatchStart;
  private watchEnd: WatchEnd;

  constructor(watchStart: WatchStart, watchEnd: WatchEnd) {
    this.closed = false;
    // paused allows the watchers to stay open for the next build
    this.paused = false;
    this.changeCallback = undefined;
    this.watchStart = watchStart;
    this.watchEnd = watchEnd;

    // Webpack requires us to track this stuff
    this.files = undefined;
    this.dirs = undefined;
    this.missing = undefined;
    this.timestamps = new Map();

    // this will be populated for us by ncc
    this.inputFileSystem = undefined;
  }

  triggerChanges(changed: string[], removed: string[]) {
    if (!this.paused) {
      if (!this.inputFileSystem) {
        throw new Error('`inputFileSystem` not set');
      }
      if (!this.changeCallback) {
        throw new Error('`changeCallback` not set');
      }

      const newTime = +Date.now();
      for (const file of changed) {
        this.timestamps.set(file, {
          safeTime: newTime + 10,
          accuracy: 10,
          timestamp: newTime
        });
        this.inputFileSystem.purge(file);
      }

      for (const file of removed) {
        this.timestamps.set(file, null);
        this.inputFileSystem.purge(file);
      }

      this.changeCallback(
        null,
        this.timestamps,
        this.timestamps,
        removed
      );
    }
  }

  // This is called on every rebuild
  watch(
    files: string[],
    dirs: string[],
    missing: string[],
    startTime: number,
    options: object,
    changeCallback: ChangeCallback
  ) {
    this.files = new Set(files);
    this.dirs = new Set(dirs);
    this.missing = new Set(missing);

    // empty object indicates "unknown" timestamp
    // (that is, not cached)
    for (const item of files)
      this.timestamps.set(item, {});
    for (const item of dirs)
      this.timestamps.set(item, {});
    // null represents "no file"
    for (const item of missing)
      this.timestamps.set(item, null);

    this.paused = false;
    this.changeCallback = changeCallback;

    // ...Start watching files, dirs, mising
    setImmediate(() => {
      this.watchStart(files, dirs, missing);
    });

    return {
      close: () => {
        this.watchEnd();
      },
      pause: () => {
        this.paused = true;
      },
      getFileTimestamps: () => {
        return this.timestamps;
      },
      getContextTimestamps: () => {
        return this.timestamps;
      }
    };
  }
}

export interface FilesConsumed {
  files: string[];
  dirs: string[];
  missing: string[];
};

export type WatcherResult = ncc.BuildResult & FilesConsumed;

export class NccWatcher {
  private watcher: CustomWatchFileSystem;
  private filesDeferred: Deferred<FilesConsumed>;
  private buildDeferred: Deferred<ncc.BuildResult>;
  public close: ncc.CloseCallback;

  constructor(entrypoint: string, options: ncc.NccOptions = {}) {
    this.watcher = new CustomWatchFileSystem(
      this.onWatchStart.bind(this),
      this.onWatchEnd.bind(this)
    );
    this.filesDeferred = createDeferred();
    this.buildDeferred = createDeferred();
    const { handler, rebuild, close } = ncc(entrypoint, {
      ...options,
      watch: this.watcher
    });
    handler(this.onBuild.bind(this));
    rebuild(this.onRebuild.bind(this));
    this.close = close;
  }

  onWatchStart(files: string[], dirs: string[], missing: string[]) {
    this.filesDeferred.resolve({ files, dirs, missing });
  }

  onWatchEnd() {
  }

  onBuild(result: ncc.BuildResult) {
    if (result.err) {
      this.buildDeferred.reject(new Error(result.err));
    } else {
      this.buildDeferred.resolve(result);
    }
  }

  onRebuild() {
  }

  async build(changed?: string[], removed?: string[]): Promise<WatcherResult> {
    if (Array.isArray(changed)) {
      this.filesDeferred = createDeferred();
      this.buildDeferred = createDeferred();
      this.watcher.triggerChanges(changed, removed || []);
    }

    const result = await Promise.all([
      this.filesDeferred.promise,
      this.buildDeferred.promise
    ]);

    return {
      ...result[0],
      ...result[1]
    };
  }
}
