"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ncc_1 = __importDefault(require("@zeit/ncc"));
const deferred_1 = require("./deferred");
class CustomWatchFileSystem {
    constructor(watchStart, watchEnd) {
        this.closed = false;
        // paused allows the watchers to stay open for the next build
        this.paused = false;
        this.changeCallback = undefined;
        this.watchStart = watchStart;
        this.watchEnd = watchEnd;
        // Webpack requires us to track this stuff
        this.files = undefined;
        this.dirs = undefined;
        this.missing = undefined;
        this.timestamps = new Map();
        // this will be populated for us by ncc
        this.inputFileSystem = undefined;
    }
    triggerChanges(changed, removed) {
        if (!this.paused) {
            if (!this.inputFileSystem) {
                throw new Error('`inputFileSystem` not set');
            }
            if (!this.changeCallback) {
                throw new Error('`changeCallback` not set');
            }
            const newTime = +Date.now();
            for (const file of changed) {
                this.timestamps.set(file, {
                    safeTime: newTime + 10,
                    accuracy: 10,
                    timestamp: newTime
                });
                this.inputFileSystem.purge(file);
            }
            for (const file of removed) {
                this.timestamps.set(file, null);
                this.inputFileSystem.purge(file);
            }
            this.changeCallback(null, this.timestamps, this.timestamps, removed);
        }
    }
    // This is called on every rebuild
    watch(files, dirs, missing, startTime, options, changeCallback) {
        this.files = new Set(files);
        this.dirs = new Set(dirs);
        this.missing = new Set(missing);
        // empty object indicates "unknown" timestamp
        // (that is, not cached)
        for (const item of files)
            this.timestamps.set(item, {});
        for (const item of dirs)
            this.timestamps.set(item, {});
        // null represents "no file"
        for (const item of missing)
            this.timestamps.set(item, null);
        this.paused = false;
        this.changeCallback = changeCallback;
        // ...Start watching files, dirs, mising
        setImmediate(() => {
            this.watchStart(files, dirs, missing);
        });
        return {
            close: () => {
                this.watchEnd();
            },
            pause: () => {
                this.paused = true;
            },
            getFileTimestamps: () => {
                return this.timestamps;
            },
            getContextTimestamps: () => {
                return this.timestamps;
            }
        };
    }
}
exports.CustomWatchFileSystem = CustomWatchFileSystem;
;
class NccWatcher {
    constructor(entrypoint, options = {}) {
        this.watcher = new CustomWatchFileSystem(this.onWatchStart.bind(this), this.onWatchEnd.bind(this));
        this.filesDeferred = deferred_1.createDeferred();
        this.buildDeferred = deferred_1.createDeferred();
        const { handler, rebuild, close } = ncc_1.default(entrypoint, {
            ...options,
            watch: this.watcher
        });
        handler(this.onBuild.bind(this));
        rebuild(this.onRebuild.bind(this));
        this.close = close;
    }
    onWatchStart(files, dirs, missing) {
        this.filesDeferred.resolve({ files, dirs, missing });
    }
    onWatchEnd() {
    }
    onBuild(result) {
        if (result.err) {
            this.buildDeferred.reject(new Error(result.err));
        }
        else {
            this.buildDeferred.resolve(result);
        }
    }
    onRebuild() {
    }
    async build(changed, removed) {
        if (Array.isArray(changed)) {
            this.filesDeferred = deferred_1.createDeferred();
            this.buildDeferred = deferred_1.createDeferred();
            this.watcher.triggerChanges(changed, removed || []);
        }
        const result = await Promise.all([
            this.filesDeferred.promise,
            this.buildDeferred.promise
        ]);
        return {
            ...result[0],
            ...result[1]
        };
    }
}
exports.NccWatcher = NccWatcher;
